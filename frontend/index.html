<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>My test page</title>

    <style>
      line,
      circle {
        stroke-width: 0.2;
      }

      line {
        stroke: black;
      }

      circle.black {
        fill: black;
        stroke: black;
      }

      circle.white {
        fill: white;
        stroke: black;
      }

      circle.pending {
        fill-opacity: 0.5;
        stroke-opacity: 0.5;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  </head>

  <body>
    <div id="app">
      <div>
        <p>{{ message }}</p>
        <span v-if="turnEnd">Time left: {{ timeLeft }}</span>
        <span>Turn {{ turnCounter }}</span>
        <label>
          <span>Play as:</span>
          <select v-model="playAs">
            <option value="black">Black</option>
            <option value="white">White</option>
          </select>
        </label>
      </div>
      <svg viewBox="-10 -10 100 100" height="400" width="400">
        <circle
          v-for="mark in marks"
          v-bind:cx="mark.x"
          v-bind:cy="mark.y"
          r="1"
        />
        <g v-for="tile in tiles">
          <line
            stroke-linecap="square"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x"
            v-bind:y2="tile.y"
          />
          <line
            v-if="tile.north"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x"
            v-bind:y2="tile.y - 5"
          />
          <line
            v-if="tile.east"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x + 5"
            v-bind:y2="tile.y"
          />
          <line
            v-if="tile.south"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x"
            v-bind:y2="tile.y + 5"
          />
          <line
            v-if="tile.west"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x - 5"
            v-bind:y2="tile.y"
          />
          <circle
            v-bind:cx="tile.x"
            v-bind:cy="tile.y"
            r="4"
            fill-opacity="0"
            v-on:click="tileClick(tile)"
          />
        </g>
        <circle
          v-for="stone in stones"
          v-bind:class="[stone.team, {pending: stone.isPending}]"
          v-bind:cx="10 * stone.x"
          v-bind:cy="10 * stone.y"
          r="4.5"
          v-on:click="stoneClick(stone)"
        />
      </svg>
    </div>
  </body>

  <script>
    var app = new Vue({
      el: "#app",
      data: {
        message: "Welcome to parallel multiplayer Go!",
        playAs: "black",
        stones: [],
        marks: [
          { x: 20, y: 20 },
          { x: 60, y: 20 },
          { x: 40, y: 40 },
          { x: 20, y: 60 },
          { x: 60, y: 60 },
        ],
        tiles: [],
        turnCounter: 0,
        turnEnd: null,
        millisecondsLeft: Infinity,
        clockTimeout: null,
      },

      computed: {
        timeLeft: function () {
          const twoDigits = (a) => a.toString().padStart(2, "0");
          const prettyTime = (a, b) => twoDigits(a) + ":" + twoDigits(b);

          if (this.millisecondsLeft < 0) {
            return prettyTime(0, 0);
          }

          const hours = Math.floor(this.millisecondsLeft / 36e5);
          const minutes = Math.floor((this.millisecondsLeft % 36e5) / 6e4);
          const seconds = Math.floor((this.millisecondsLeft % 6e4) / 1e3);

          return hours > 0
            ? prettyTime(hours, minutes)
            : prettyTime(minutes, seconds);
        },
      },

      created: function () {
        this.createTiles();
        this.update();
      },

      methods: {
        createTiles: function () {
          const rows = 9;
          const columns = 9;
          for (let row = 0; row < rows; ++row) {
            for (let column = 0; column < columns; ++column) {
              this.tiles.push({
                x: column * 10,
                y: row * 10,
                north: row > 0,
                east: column < columns - 1,
                south: row < rows - 1,
                west: column > 0,
              });
            }
          }
        },

        update: function () {
          this.getGameSate();
          this.getStones();
        },

        getGameSate: function () {
          fetch("http://localhost:3000/gameState", {
            method: "GET",
            mode: "cors",
            cache: "reload",
          })
            .then((response) => {
              if (response.status === 200) {
                return response.json();
              }

              return Promise.reject(
                new Error(response.statusText + "(" + response.status + ")")
              );
            })
            .then((gameState) => {
              this.turnCounter = gameState.turnCounter;
              this.turnEnd = new Date(gameState.turnEnd);
              this.millisecondsLeft = this.turnEnd - new Date();
              setTimeout(this.update, this.millisecondsLeft);
              this.updateTurnClock();
            })
            .catch((error) => {
              alert(error);
              console.log(error);
            });
        },

        getStones: function () {
          fetch("http:\\localhost:3000", {
            method: "GET",
            mode: "cors",
            cache: "reload",
          })
            .then((response) => {
              if (response.status === 200) {
                return response.json();
              }

              return Promise.reject(
                new Error(response.statusText + "(" + response.status + ")")
              );
            })
            .then((stones) => {
              this.stones = stones;
            })
            .catch((error) => {
              alert(error);
              console.log(error);
            });
        },

        tileClick: function (tile) {
          fetch("http:\\localhost:3000", {
            method: "POST",
            mode: "cors",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              x: tile.x / 10,
              y: tile.y / 10,
              team: this.playAs,
              isPending: true,
            }),
          })
            .then(async (response) => {
              if (response.status === 200) {
                return response.json();
              }

              const text = await response.text();
              const error = new Error(
                `${response.statusText} (${response.status}): \n${text}`
              );
              return Promise.reject(error);
            })
            .then((stone) => {
              this.stones.push(stone);
            })
            .catch((error) => {
              alert(error);
              console.log(error);
            });
        },

        stoneClick: function (stone) {
          if (!stone.isPending) {
            return;
          }

          fetch("http://localhost:3000/removePendingStone", {
            method: "POST",
            mode: "cors",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(stone),
          })
            .then(async (response) => {
              if (response.status === 200) {
                return response.json();
              }

              const text = await response.text();
              const error = new Error(
                `${response.statusText} (${response.status}): \n${text}`
              );
              return Promise.reject(error);
            })
            .then(() => this.stones.splice(this.stones.indexOf(stone), 1))
            .catch((error) => {
              alert(error);
              console.log(error);
            });
        },

        updateTurnClock: function () {
          this.millisecondsLeft = this.turnEnd - new Date();
          if (this.millisecondsLeft <= 0) {
            return;
          }

          const millisecondsUntilClockUpdate =
            this.millisecondsLeft > 6e5
              ? this.millisecondsLeft % 6e5
              : this.millisecondsLeft % 1e3;

          this.clockTimeout = setTimeout(
            this.updateTurnClock,
            millisecondsUntilClockUpdate
          );
        },
      },
    });
  </script>
</html>
