<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>My test page</title>

    <style>
      line,
      circle {
        stroke-width: 0.2;
      }

      line {
        stroke: black;
      }

      circle.stone {
        stroke: black;
      }

      circle.stone.pending {
        fill-opacity: 0.5;
        stroke-opacity: 0.5;
      }

      circle.newStoneMarker {
        fill: none;
        stroke-width: 0.5;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  </head>

  <body>
    <div id="app">
      <div v-if="!user">
        <label>
          <span>Username:</span>
          <input type="text" v-model="username" />
        </label>
        <label>
          <span>Password:</span>
          <input type="password" v-model="password" />
        </label>
        <button type="button" v-on:click="login()">Login</button>
        <button type="button" v-on:click="register()">Register</button>
      </div>

      <div v-if="user">
        <span>Playing as {{ user.name }}</span>
        <button type="button" v-on:click="logout()">Logout</button>
        <br />
        <label>
          <span>Primary Color:</span>
          <input type="color" v-model="user.color" v-on:change="setColor()" />
        </label>
        <label>
          <span>Secondary Color:</span>
          <input
            type="color"
            v-model="user.secondaryColor"
            v-on:change="setColor()"
          />
        </label>
        <br />
        <svg viewBox="-5 -5 10 10" height="50" width="50">
          <circle
            cx="0"
            cy="0"
            r="4.5"
            class="stone"
            v-bind:fill="user.color"
          />
          <circle
            cx="0"
            cy="0"
            r="2"
            class="newStoneMarker"
            v-bind:stroke="user.secondaryColor"
          />
        </svg>
      </div>

      <div v-if="!gameId">
        <p>Select game:</p>
        <ul>
          <li v-for="game in games" v-on:click="setGame(game._id)">
            {{ game._id }}
          </li>
        </ul>
        <label>
          <span>Board size: </span>
          <input type="number" v-model="newGame.boardSize" />
        </label>
        <label>
          <span>Turn time: </span>
          <input type="number" v-model="newGame.turnTime" />
        </label>
        <button type="button" v-on:click="newGame()">New game</button>
      </div>

      <div v-if="gameId">
        <div>
          <p>{{ message }}</p>
          <span v-if="turnEnd">Time left: {{ timeLeft }}</span>
          <span>Turn {{ turnCounter }}</span>
          <button v-if="user" type="button" v-on:click="haltTurn()">
            Halt turn
          </button>
          <button v-if="user" type="button" v-on:click="endTurn()">
            End turn
          </button>
        </div>
        <svg v-bind:view-box.camel="board.viewBox" height="600" width="600">
          <circle
            v-for="mark in board.marks"
            v-bind:cx="mark.x"
            v-bind:cy="mark.y"
            r="1"
          />
          <g v-for="tile in board.tiles">
            <line
              stroke-linecap="square"
              v-bind:x1="tile.x"
              v-bind:y1="tile.y"
              v-bind:x2="tile.x"
              v-bind:y2="tile.y"
            />
            <line
              v-if="tile.north"
              v-bind:x1="tile.x"
              v-bind:y1="tile.y"
              v-bind:x2="tile.x"
              v-bind:y2="tile.y - 5"
            />
            <line
              v-if="tile.east"
              v-bind:x1="tile.x"
              v-bind:y1="tile.y"
              v-bind:x2="tile.x + 5"
              v-bind:y2="tile.y"
            />
            <line
              v-if="tile.south"
              v-bind:x1="tile.x"
              v-bind:y1="tile.y"
              v-bind:x2="tile.x"
              v-bind:y2="tile.y + 5"
            />
            <line
              v-if="tile.west"
              v-bind:x1="tile.x"
              v-bind:y1="tile.y"
              v-bind:x2="tile.x - 5"
              v-bind:y2="tile.y"
            />
            <circle
              v-bind:cx="tile.x"
              v-bind:cy="tile.y"
              r="4"
              fill-opacity="0"
              v-on:click="tileClick(tile)"
            />
          </g>
          <g v-for="stone in stones">
            <go-stone
              v-bind:stone="stone"
              v-bind:turn-counter="turnCounter"
              v-on:stone-click="stoneClick(stone)"
            />
          </g>
        </svg>
      </div>
    </div>
  </body>

  <script>
    Vue.component("go-stone", {
      props: {
        stone: Object,
        turnCounter: Number,
      },
      computed: {
        markerColor: ({ stone }) =>
          stone.removedOnTurn ? stone.user.color : stone.user.secondaryColor,
        showStone: ({ stone }) => !stone.removedOnTurn,
        showMarker: ({ stone, turnCounter }) =>
          turnCounter - stone.placedOnTurn === 1,
      },
      template: `
        <g>
          <circle
            v-if="showStone"
            v-bind:class="['stone', {pending: stone.isPending}]"
            v-bind:cx="10 * stone.x"
            v-bind:cy="10 * stone.y"
            v-bind:fill="stone.user.color"
            r="4.5"
            v-on:click="$emit('stone-click', stone)"
          />
          <circle
            v-if="showMarker"
            class="newStoneMarker"
            v-bind:cx="10 * stone.x"
            v-bind:cy="10 * stone.y"
            r="2"
            v-bind:stroke="markerColor"
          />
        </g>
      `,
    });

    var app = new Vue({
      el: "#app",
      data: {
        message: "Welcome to parallel multiplayer Go!",
        username: "",
        password: "",
        user: null,
        games: [],
        gameId: null,
        stones: [],
        boardSize: null,
        turnCounter: 0,
        turnEnd: null,
        millisecondsLeft: Infinity,
        clockTimeout: null,
      },

      computed: {
        timeLeft: function () {
          const twoDigits = (a) => a.toString().padStart(2, "0");
          const prettyTime = (a, b) => twoDigits(a) + ":" + twoDigits(b);

          if (this.millisecondsLeft === Infinity) {
            return "paused";
          }

          if (this.millisecondsLeft < 0) {
            return prettyTime(0, 0);
          }

          const hours = Math.floor(this.millisecondsLeft / 36e5);
          const minutes = Math.floor((this.millisecondsLeft % 36e5) / 6e4);
          const seconds = Math.floor((this.millisecondsLeft % 6e4) / 1e3);

          return hours > 0
            ? prettyTime(hours, minutes)
            : prettyTime(minutes, seconds);
        },

        board: function () {
          const board = {};
          const svgFactor = 10;

          const tiles = [];
          const rows = this.boardSize;
          const columns = this.boardSize;
          for (let row = 0; row < rows; ++row) {
            for (let column = 0; column < columns; ++column) {
              tiles.push({
                x: column * svgFactor,
                y: row * svgFactor,
                north: row > 0,
                east: column < columns - 1,
                south: row < rows - 1,
                west: column > 0,
              });
            }
          }

          const marks = [];
          const left = { x: svgFactor * (this.boardSize < 13 ? 2 : 3) };
          const right = { x: svgFactor * (this.boardSize - 1) - left.x };
          const top = { y: left.x };
          const bottom = { y: right.x };

          marks.push({ ...left, ...top });
          marks.push({ ...right, ...top });
          marks.push({ ...left, ...bottom });
          marks.push({ ...right, ...bottom });

          if (this.boardSize % 2 > 0) {
            const mid = svgFactor * 0.5 * (this.boardSize - 1);
            const midRow = { y: mid };
            const midColumn = { x: mid };
            marks.push({ ...midRow, ...midColumn });

            if (this.boardSize >= 15) {
              marks.push({ ...left, ...midRow });
              marks.push({ ...right, ...midRow });
              marks.push({ ...midColumn, ...top });
              marks.push({ ...midColumn, ...bottom });
            }
          }

          const viewBoxStart = -svgFactor;
          const viewBoxSize = svgFactor * (this.boardSize + 1);

          board.tiles = tiles;
          board.marks = marks;
          board.viewBox = `${viewBoxStart} ${viewBoxStart} ${viewBoxSize} ${viewBoxSize}`;

          return board;
        },
      },

      created: function () {
        if (this.game) {
          this.update();
        } else {
          this.getGames();
        }
        this.checkLogin();
      },

      methods: {
        setGame: function (id) {
          this.gameId = id;
          this.update();
        },

        getGames: async function () {
          this.games = await this.fetch("games/list");
        },

        newGame: async function () {
          this.games.push(
            await this.fetch("games", {
              method: "POST",
              body: JSON.stringify({
                boardSize: this.newGame.boardSize,
                turnTime: this.newGame.turnTime * 1000,
              }),
            })
          );
        },

        haltTurn: async function () {
          await this.fetch(`games/${this.gameId}/haltTurn`, { method: "POST" });
          this.getGameSate();
        },

        endTurn: async function () {
          await this.fetch(`games/${this.gameId}/endTurn`, { method: "POST" });
          this.update();
        },

        update: function () {
          this.getGameSate();
          this.getStones();
        },

        getGameSate: async function () {
          const gameState = await this.fetch(`games/${this.gameId}/gameState`);
          this.boardSize = gameState.boardSize;
          this.turnCounter = gameState.turnCounter;
          this.turnEnd = new Date(gameState.turnEnd);

          this.updateTurnClock();
          if (this.millisecondsLeft !== Infinity) {
            setTimeout(this.update, this.millisecondsLeft);
          }
        },

        getStones: async function () {
          this.stones = await this.fetch(`games/${this.gameId}/getStones`);
        },

        tileClick: async function (tile) {
          const stone = await this.fetch(`games/${this.gameId}/addStone`, {
            method: "POST",
            body: JSON.stringify({
              x: tile.x / 10,
              y: tile.y / 10,
              user: this.user,
              isPending: true,
            }),
          });
          this.stones.push(stone);
        },

        stoneClick: async function (stone) {
          if (!stone.isPending) {
            return;
          }

          await this.fetch(`games/${this.gameId}/removePendingStone`, {
            method: "POST",
            body: JSON.stringify(stone),
          });

          this.stones.splice(this.stones.indexOf(stone), 1);
        },

        updateTurnClock: function () {
          const MAX_DATE = new Date(8640000000000000);
          this.millisecondsLeft =
            this.turnEnd < MAX_DATE ? this.turnEnd - new Date() : Infinity;
          if (
            this.millisecondsLeft <= 0 ||
            this.millisecondsLeft === Infinity
          ) {
            return;
          }

          const millisecondsUntilClockUpdate =
            this.millisecondsLeft > 6e5
              ? this.millisecondsLeft % 6e5
              : this.millisecondsLeft % 1e3;

          this.clockTimeout = setTimeout(
            this.updateTurnClock,
            millisecondsUntilClockUpdate
          );
        },

        checkLogin: async function () {
          this.user = await this.fetch("checkLogin");
        },

        login: async function () {
          this.user = await this.fetch("login", {
            method: "POST",
            body: JSON.stringify({
              username: this.username,
              password: this.password,
            }),
          });
          this.password = null;
        },

        register: async function () {
          this.user = await this.fetch("register", {
            method: "POST",
            body: JSON.stringify({
              username: this.username,
              password: this.password,
            }),
          });
          this.password = null;
        },

        logout: async function () {
          await this.fetch("logout");
          this.user = null;
        },

        setColor: async function () {
          await this.fetch("setColors", {
            method: "POST",
            body: JSON.stringify({
              color: this.user.color,
              secondaryColor: this.user.secondaryColor,
            }),
          });
        },

        fetch: async function (resource, init) {
          try {
            const defaultInit = {
              method: "GET",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
              },
            };
            const response = await fetch(
              `http://localhost:3000/${resource}`,
              Object.assign(defaultInit, init)
            );

            if (!response.ok) {
              throw new Error(
                response.statusText + "(" + response.status + ")"
              );
            }

            const contentType = response.headers.get("content-type");
            if (contentType.includes("text/plain")) {
              const text = await response.text();
              if (text !== "OK") {
                throw new Error(
                  `JSON expected but response was text:\n${text}`
                );
              }
              return true;
            }

            if (contentType.includes("application/json")) {
              return await response.json();
            }

            throw new Error(
              `Response has unknown content type: ${contentType}`
            );
          } catch (error) {
            alert(error);
            throw error;
          }
        },
      },
    });
  </script>
</html>
