<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>My test page</title>

    <style>
      line,
      circle {
        stroke-width: 0.2;
      }

      line {
        stroke: black;
      }

      circle.stone {
        stroke: black;
      }

      circle.stone.pending {
        fill-opacity: 0.5;
        stroke-opacity: 0.5;
      }

      circle.newStoneMarker {
        fill: none;
        stroke-width: 0.5;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  </head>

  <body>
    <div id="app">
      <div v-if="!user">
        <label>
          <span>Username:</span>
          <input type="text" v-model="username" />
        </label>
        <label>
          <span>Password:</span>
          <input type="password" v-model="password" />
        </label>
        <button type="button" v-on:click="login()">Login</button>
        <button type="button" v-on:click="register()">Register</button>
      </div>

      <div v-if="user">
        <span>Playing as {{ user.name }}</span>
        <button type="button" v-on:click="logout()">Logout</button>
        <br />
        <label>
          <span>Primary Color:</span>
          <input type="color" v-model="user.color" v-on:change="setColor()" />
        </label>
        <label>
          <span>Secondary Color:</span>
          <input
            type="color"
            v-model="user.secondaryColor"
            v-on:change="setColor()"
          />
        </label>
        <br />
        <svg viewBox="-5 -5 10 10" height="50" width="50">
          <circle
            cx="0"
            cy="0"
            r="4.5"
            class="stone"
            v-bind:fill="user.color"
          />
          <circle
            cx="0"
            cy="0"
            r="2"
            class="newStoneMarker"
            v-bind:stroke="user.secondaryColor"
          />
        </svg>
      </div>

      <div>
        <p>{{ message }}</p>
        <span v-if="turnEnd">Time left: {{ timeLeft }}</span>
        <span>Turn {{ turnCounter }}</span>
      </div>
      <svg viewBox="-10 -10 100 100" height="400" width="400">
        <circle
          v-for="mark in marks"
          v-bind:cx="mark.x"
          v-bind:cy="mark.y"
          r="1"
        />
        <g v-for="tile in tiles">
          <line
            stroke-linecap="square"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x"
            v-bind:y2="tile.y"
          />
          <line
            v-if="tile.north"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x"
            v-bind:y2="tile.y - 5"
          />
          <line
            v-if="tile.east"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x + 5"
            v-bind:y2="tile.y"
          />
          <line
            v-if="tile.south"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x"
            v-bind:y2="tile.y + 5"
          />
          <line
            v-if="tile.west"
            v-bind:x1="tile.x"
            v-bind:y1="tile.y"
            v-bind:x2="tile.x - 5"
            v-bind:y2="tile.y"
          />
          <circle
            v-bind:cx="tile.x"
            v-bind:cy="tile.y"
            r="4"
            fill-opacity="0"
            v-on:click="tileClick(tile)"
          />
        </g>
        <g v-for="stone in stones">
          <circle
            v-bind:class="['stone', {pending: stone.isPending}]"
            v-bind:cx="10 * stone.x"
            v-bind:cy="10 * stone.y"
            v-bind:fill="stone.user.color"
            r="4.5"
            v-on:click="stoneClick(stone)"
          />
          <circle
            v-if="turnCounter - stone.placedOnTurn === 1"
            class="newStoneMarker"
            v-bind:cx="10 * stone.x"
            v-bind:cy="10 * stone.y"
            r="2"
            v-bind:stroke="stone.user.secondaryColor"
          />
        </g>
      </svg>
    </div>
  </body>

  <script>
    var app = new Vue({
      el: "#app",
      data: {
        message: "Welcome to parallel multiplayer Go!",
        username: "",
        password: "",
        user: null,
        stones: [],
        marks: [
          { x: 20, y: 20 },
          { x: 60, y: 20 },
          { x: 40, y: 40 },
          { x: 20, y: 60 },
          { x: 60, y: 60 },
        ],
        tiles: [],
        turnCounter: 0,
        turnEnd: null,
        millisecondsLeft: Infinity,
        clockTimeout: null,
      },

      computed: {
        timeLeft: function () {
          const twoDigits = (a) => a.toString().padStart(2, "0");
          const prettyTime = (a, b) => twoDigits(a) + ":" + twoDigits(b);

          if (this.millisecondsLeft < 0) {
            return prettyTime(0, 0);
          }

          const hours = Math.floor(this.millisecondsLeft / 36e5);
          const minutes = Math.floor((this.millisecondsLeft % 36e5) / 6e4);
          const seconds = Math.floor((this.millisecondsLeft % 6e4) / 1e3);

          return hours > 0
            ? prettyTime(hours, minutes)
            : prettyTime(minutes, seconds);
        },
      },

      created: function () {
        this.createTiles();
        this.update();
        this.checkLogin();
      },

      methods: {
        createTiles: function () {
          const rows = 9;
          const columns = 9;
          for (let row = 0; row < rows; ++row) {
            for (let column = 0; column < columns; ++column) {
              this.tiles.push({
                x: column * 10,
                y: row * 10,
                north: row > 0,
                east: column < columns - 1,
                south: row < rows - 1,
                west: column > 0,
              });
            }
          }
        },

        update: function () {
          this.getGameSate();
          this.getStones();
        },

        getGameSate: async function () {
          const gameState = await this.fetch("gameState");
          this.turnCounter = gameState.turnCounter;
          this.turnEnd = new Date(gameState.turnEnd);
          this.millisecondsLeft = this.turnEnd - new Date();
          setTimeout(this.update, this.millisecondsLeft);
          this.updateTurnClock();
        },

        getStones: async function () {
          this.stones = await this.fetch("");
        },

        tileClick: async function (tile) {
          const stone = await this.fetch("", {
            method: "POST",
            body: JSON.stringify({
              x: tile.x / 10,
              y: tile.y / 10,
              user: this.user,
              isPending: true,
            }),
          });
          this.stones.push(stone);
        },

        stoneClick: async function (stone) {
          if (!stone.isPending) {
            return;
          }

          await this.fetch("removePendingStone", {
            method: "POST",
            body: JSON.stringify(stone),
          });

          this.stones.splice(this.stones.indexOf(stone), 1);
        },

        updateTurnClock: function () {
          this.millisecondsLeft = this.turnEnd - new Date();
          if (this.millisecondsLeft <= 0) {
            return;
          }

          const millisecondsUntilClockUpdate =
            this.millisecondsLeft > 6e5
              ? this.millisecondsLeft % 6e5
              : this.millisecondsLeft % 1e3;

          this.clockTimeout = setTimeout(
            this.updateTurnClock,
            millisecondsUntilClockUpdate
          );
        },

        checkLogin: async function () {
          this.user = await this.fetch("checkLogin");
        },

        login: async function () {
          this.user = await this.fetch("login", {
            method: "POST",
            body: JSON.stringify({
              username: this.username,
              password: this.password,
            }),
          });
          this.password = null;
        },

        register: async function () {
          this.user = await this.fetch("register", {
            method: "POST",
            body: JSON.stringify({
              username: this.username,
              password: this.password,
            }),
          });
          this.password = null;
        },

        logout: async function () {
          await this.fetch("logout");
          this.user = null;
        },

        setColor: async function () {
          await this.fetch("setColors", {
            method: "POST",
            body: JSON.stringify({
              color: this.user.color,
              secondaryColor: this.user.secondaryColor,
            }),
          });
        },

        fetch: async function (resource, init) {
          try {
            const defaultInit = {
              method: "GET",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
              },
            };
            const response = await fetch(
              `http://localhost:3000/${resource}`,
              Object.assign(defaultInit, init)
            );

            if (!response.ok) {
              throw new Error(
                response.statusText + "(" + response.status + ")"
              );
            }

            const contentType = response.headers.get("content-type");
            if (contentType.includes("text/plain")) {
              const text = await response.text();
              if (text !== "OK") {
                throw new Error(
                  `JSON expected but response was text:\n${text}`
                );
              }
              return true;
            }

            if (contentType.includes("application/json")) {
              return await response.json();
            }

            throw new Error(
              `Response has unknown content type: ${contentType}`
            );
          } catch (error) {
            alert(error);
            console.log(error);
          }
        },
      },
    });
  </script>
</html>
